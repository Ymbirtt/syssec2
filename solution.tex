\section{Network Attacks}

In each of these attacks, three virtual machines were placed on a virtual network with a virtual DHCP server. Each one
was assigned an IP address in the range 192.168.0.122-192.168.0.124 inclusive. Unless stated otherwise, whenever a
client or server is mentioned the server is running netcat at address 192.168.0.124 on port 4444, and the client is
attempting to connect to it from address 192.168.0.122. Specifically, the server runs {\tt nc -l -p 4444}, and the
client runs {\tt nc 192.168.0.124 4444}.

\subsection{ARP Poisoning and ICMP Redirection}

Both of these attacks achieve roughly the same goal -- deceiving victims about the state of the network. The system's
ARP cache records information on which device holds what network address. Usually, when two devices want to communicate
to each other, an ARP request is broadcast to the entire network, and the relevant device responds with its MAC address.
This process can be subverted by continually sending fake responses, declaring false information about the mapping from
network addresses to hardware addresses. {\tt netwox 80 -e 08:00:27:10:42:0A -i 192.168.0.124} repeatedly sends a forged
ARP response, delcaring that address 192.168.0.0 belongs to device 08:00:27:10:42:0A. If 192.168.0.122 then attempts to
ping 192.168.0.0, it will send out an ARP request, find a response stating that the device exists, and then attempt to
send ping packets to it. However, in this network this address does not exist, so the packets will go nowhere and the
sender will hang. Occasionally the sender will send out another ARP request, suspecting that the state of the network
may have changed and that the packets should be routed to a different device, but it will quickly pick up one of the
fake responses and continue with its futile operation. This, however, creates a very noisy network. It is fairly easy to
spot someone sending a large number of unsolicited ARP responses and take appropriate action. Running {\tt arp -n} on
any machine on the network will show that address 192.168.0.0 exists, and that it belongs to 08:00:27:10:42:0A. When,
however, the attacker stops sending these forged ARP responses, the network will quickly return to normal, and packets
will be routed to the correct devices.

Far more subtle is the ICMP Redirect attack. On a large network, where devices may not necessarily be directly connected
to each other, it is necessary to find routes through the network from host to host, via intermediate routers. In the
virtual network to which the virtual machines are connected, a direct route exists from each host to each other host. An
adversary listening on the network cannot pick up any traffic that is not intended for him.

%Picture of deaf adversary goes here

When the state of a network changes, a redirect packet is broadcast, advising hosts of the new ``best" route to a
destination. These packets can, of course, be spoofed. The command {\tt netwox 86 -d eth6 -g 192.168.0.123} will cause
an adversary to listen for any network activity on the network that {\tt eth6} is connected to, and when some is
detected will send a redirect packet suggesting that the data should be routed through 192.168.0.123 instead. Options
also exist that allow an attacker to respond only to certain traffic. An adversary can advise the network that the best
route to any host is directly through him, allowing him to read any network traffic that is sent between hosts on the
network.

%Picture of adversary listening to traffic goes here

This allows an adversary to read anything that his targets attempt to send to each other, until the routing table is
updated again Since the routing table is only updated when the route to the target host changes, the effects of such an
attack can persist for a very long time. Insecure protocols like Telnet can leak logon credentials in the plain, as well
as the contents of any files that a client reads.

\subsection{SYN Flooding}

In ordinary usage, to form a TCP connection a client sends a SYN packet to synchronise clocks with the server,
containing a sequence number, $S_c$, which can be any arbitrary value. The server responds with a SYN/ACK packet,
containing a sequence number $S_s$, and an acknowledgement number, $A_s = S_c+1$. The client then returns an ACK packet
to acknowledge this synchronisation containing an acknowledgement number $A_c = S_s+1$, and start the connection. If a
server wants to allow multiple connections, which servers usually do, it will need to store the state of multiple TCP
sessions in memory. If a server has too many active sessions, then it will be unable to accept any more, denying any
services it might offer to legitimate clients. This is called a SYN flood. Netwox tool 76 implements this attack. {\tt
netwox 76 -i 192.168.0.124 -p 4444} will repeatedly send SYN packets to port 4444 of host 192.168.0.124, with randomised
sender addresses. The server will respond to each of these connections with the requisite SYN/ACK, then store the state
of these connections in a buffer. With the SYN cookie disabled, when that buffer fills it'll simply discard the oldest
connection, ignoring any connections sent in whilst it discards. If a legitimate client then attempts to access the
server, it'll find that the server is too busy handling the malicious requests, and have its own request pushed off the
end of the buffer. The server will forget about the client, and the client will eventually give up on the connection,
returning a timeout.

When the SYN cookie is enabled, however, connections can be established without a problem. A SYN cookie places
restrictions on the valid ACK numbers that can be sent back to the server by a client. When the server receives a SYN
packet, rather than picking an arbitrary $S_s$, it picks an $S_s$ such that the first 5 bits are a slowly incrementing
timestamp, $t$, the next 3 bits encode the maximum segment Size, and the final 24 bits encode an easy to compute secure
hash function of the client's address and port number, the server's address and port number, and the value of the
timestamp $t$. The server can then completely forget about this connection. When the client responds with $A_c$, the
server can recompute the preceding and compare it to $A_c-1$. If they match, then the connection must have been started
legitimately, and the server can respond to it. Since the timestamp increases slowly -- $t$ increments once every 64
seconds is typical -- it is reasonable for the server to assume that the client will have responded within the same time
window. It is not infeasible for the server to also compute all the necessary data for timestamp $t-1$, to cover the
case where a connection straddles two windows.

The use of a SYN cookie allows the server to store no information whatsoever about the state of partially completed
connections, so no resources are consumed by incomplete connections. As an aside, when the server was running Wireshark
as a background process, the cost of redrawing the GUI as rapidly as packets were being sent caused the system to
completely lock up. It is not impossible for a sufficiently low-power device running sufficiently misconfigured logging
software to be completely disabled by such an attack.

\subsection{TCP RST Attacks on telnet, ssh and ``video streaming"}

Each TCP packet contains an RST flag. If this flag is set to 1, then the packet declares that the connection should
immediately be aborted. Under normal usage, it is usually used to show that a problem has occurred with one of the
hosts. If one host crashes, then the other would attempt to continue sending data to it fruitlessly. If, during crash
recovery, one host responds to the incoming data with an RST packet, the other will know to stop sending data and take
appropriate action. This is also used to help limit network activity, and shut down connections that are deemed to be
malicious

In the attack, netwox %WHICH TOOL?
listens for TCP activity on the network, and as soon as packets are sniffed, sends a forged TCP RST to both endpoints.
During a telnet session, this causes both hosts to hang up, believing something to have happened to the other. The same
outcome is observed during an ssh session. Attacking a video streaming application is non-trivial on Ubuntu 9.04. Most
video streaming websites rely on Adobe Flash. There are no easy to find legacy builds of Adobe Flash available for such
an old operating system, so instead a video streaming application was simulated using netcat, fortune and cowsay;
specifically with the BASH command {\tt while [ 1 ] do; fortune | cowsay -f dragon; done | nc -l -p 4444}. An RST packet
had the expected effect of terminating this connection for both the server and the client.

\subsection{TCP Hijacking}

telnet does not encrypt its communications, and is completely vulnerable to a myriad of attacks. Session hijacking
intercepts telnet traffic, then sends packets with a spoofed source IP, a valid sequence number, and standard telnet
traffic. The server cannot tell the difference between this traffic and traffic legitimately sent by the client. This
allows an attacker to take control of a telnet session and execute arbitrary commands.

Though this is theoretically possible using netwox, hand-crafting each individual packet to contain the correct sequence
number and valid commands, this is very difficult. Tools exist to automate this process, and we downloaded and installed
hunt onto our attacker's machine to make this easier for ourselves. Hunt needs to scan the network in advance to find
telnet hosts, then can list active telnet connections when they start. When requested, hunt can intercept the session,
passing control over to the attacker as though he had connected originally. This quickly causes the legitimate client's
sequence numbers to go out of sync, meaning that any traffic sent by him is rejected by the server, and any traffic sent
by the server is rejected by the legitimate client. This includes the standard logout message. The client will hang and,
unless he knows the symptoms of such an attack, will just think that the server has crashed. An aware server could
probably detect the two incoming streams of telnet traffic, and possibly be able to send out an RST packet to abort the
connection, but a better solution is to use a secure remote shell, like ssh.
